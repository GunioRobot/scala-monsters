package no.lau.domain

import collection.mutable.HashMap
import no.lau.movement.{QueuedMovement, Movable}
import scala.util.Random

/**
 * BoardSize X and Y start from 0 to make computation easier to write :)
 */
class Game(boardSizeX: Int, boardSizeY: Int) {

  var gameBoards:List[HashMap[Tuple2[Int, Int], GamePiece]] = List(new HashMap[Tuple2[Int, Int], GamePiece])

  def currentGameBoard():HashMap[Tuple2[Int, Int], GamePiece] = gameBoards.first
  def previousGameBoard():HashMap[Tuple2[Int, Int], GamePiece] = {
    if(gameBoards.tail.size > 0)
      gameBoards.tail.first
    else
      gameBoards.first
  }

  def newTurn = {
    gameBoards = cloneCurrent :: gameBoards
    for(gamePiece <- previousGameBoard.values) {
      (gamePiece, gamePiece) match {
        case (stackable: QueuedMovement, movable: Movable) => {

          if (stackable.movementQueue.size > 0) println(stackable.movementQueue)

          stackable.movementQueue.firstOption match {
            case Some(direction) => {
              try {
                movable.move(direction)
                stackable.movementQueue = stackable.movementQueue.tail
              } catch {
                case ime: IllegalMoveException => {
                  //println("Illegal Move for " + movable + ": " + ime.getMessage)
                  stackable.movementQueue = List()
                  stackable.progressionHalted
                }
              }
            }
            case None =>
          }
        }
        case _ =>
      }
    }
    //Check if the movement collides with other movements, in which case, roll back both movements

    currentGameBoard
  }

  private def cloneCurrent = currentGameBoard.clone.asInstanceOf[HashMap[Tuple2[Int, Int], GamePiece]]

  /**
   * Simple algorithm for selecting free tiles on a board
   */
  def findRandomFreeCell(): Tuple2[Int, Int] = {
    val freeCells = for {
      i <- 0 to boardSizeX
      j <- 0 to boardSizeY
      if currentGameBoard.get((i, j)) isEmpty}
    yield (i, j)

    freeCells(new Random().nextInt(freeCells.length))
  }

  def addRandomly(gamePiece: GamePiece) = currentGameBoard += findRandomFreeCell -> gamePiece

  def whereIs(gamePiece: GamePiece, gameBoard:HashMap[Tuple2[Int, Int], GamePiece]): Option[Tuple2[Int, Int]] = {
    val foundItAt: Int = gameBoard.values.indexOf(gamePiece)
    if(foundItAt != -1)
      Some(gameBoard.keySet.toArray(foundItAt))
    else
      None
  }

  def printableBoard = {
    val table = for (y <- 0 to boardSizeY)
    yield {
        val row = for (x <- 0 to boardSizeX) yield currentGameBoard.getOrElse((x, boardSizeY - y), ".")
        row.foldLeft("")(_ + _) + "\n"
      }
    table.foldLeft("")(_ + _)
  }

  createBoarder()
  
  def createBoarder() {
    for(x <- 0 to boardSizeX; y <- 1 to boardSizeY -1) {
      currentGameBoard += (x, 0) -> new StaticWall()
      currentGameBoard += (x, boardSizeY) -> new StaticWall()
      currentGameBoard += (0, y) -> new StaticWall()
      currentGameBoard += (boardSizeX, y) -> new StaticWall()
    }
  }
}

trait GamePiece

case class Monster(game: Game, id: Any) extends GamePiece{ override def toString = "H" }

trait Player { override def toString = "âˆ†" }

//Todo blocks should need no identity. When one is moved, it is essentially deleted, and replaced by a new. If possible :) Or has an autogenerated id
case class Block(game: Game, id: Any) extends Movable {override def toString = "B"}

case class StaticWall() extends GamePiece {override def toString = "W"}

/**
 * Marks that a gamePiece can be killed
 */
trait Mortal { def kill {println(this + " was killed!")} }
// Marks that a Monster kan kill by eating
trait Meelee

//Able to push stuff todo should have a set value of number of movables it can push
trait Pusher

case class IllegalMoveException(val message: String) extends Throwable {
  override def getMessage = message
}

